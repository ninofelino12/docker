import type { Env } from "./app";
/**
 * The purpose of this hook is to allow components to get a reference to a sub
 * html node or component.
 */
export declare function useRef<T extends HTMLElement = HTMLElement>(name: string): {
    el: T | null;
};
/**
 * This hook is useful as a building block for some customized hooks, that may
 * need a reference to the env of the component calling them.
 */
export declare function useEnv<E extends Env>(): E;
/**
 * This hook is a simple way to let components use a sub environment.  Note that
 * like for all hooks, it is important that this is only called in the
 * constructor method.
 */
export declare function useSubEnv(envExtension: Env): void;
export declare function useChildSubEnv(envExtension: Env): void;
declare type EffectDeps<T extends unknown[]> = T | (T extends [...infer H, never] ? EffectDeps<H> : never);
/**
 * @template T
 * @param {...T} dependencies the dependencies computed by computeDependencies
 * @returns {void|(()=>void)} a cleanup function that reverses the side
 *      effects of the effect callback.
 */
declare type Effect<T extends unknown[]> = (...dependencies: EffectDeps<T>) => void | (() => void);
/**
 * This hook will run a callback when a component is mounted and patched, and
 * will run a cleanup function before patching and before unmounting the
 * the component.
 *
 * @template T
 * @param {Effect<T>} effect the effect to run on component mount and/or patch
 * @param {()=>[...T]} [computeDependencies=()=>[NaN]] a callback to compute
 *      dependencies that will decide if the effect needs to be cleaned up and
 *      run again. If the dependencies did not change, the effect will not run
 *      again. The default value returns an array containing only NaN because
 *      NaN !== NaN, which will cause the effect to rerun on every patch.
 */
export declare function useEffect<T extends unknown[]>(effect: Effect<T>, computeDependencies?: () => [...T]): void;
/**
 * When a component needs to listen to DOM Events on element(s) that are not
 * part of his hierarchy, we can use the `useExternalListener` hook.
 * It will correctly add and remove the event listener, whenever the
 * component is mounted and unmounted.
 *
 * Example:
 *  a menu needs to listen to the click on window to be closed automatically
 *
 * Usage:
 *  in the constructor of the OWL component that needs to be notified,
 *  `useExternalListener(window, 'click', this._doSomething);`
 * */
export declare function useExternalListener(target: EventTarget, eventName: string, handler: EventListener, eventParams?: AddEventListenerOptions): void;
export {};
