import type { App, Env } from "./app";
import { BDom, VNode } from "./blockdom";
import { Component, ComponentConstructor, Props } from "./component";
import { Fiber, MountFiber, MountOptions } from "./fibers";
import { getSubscriptions } from "./reactivity";
import { STATUS } from "./status";
export declare function getCurrent(): ComponentNode;
export declare function useComponent(): Component;
/**
 * Creates a reactive object that will be observed by the current component.
 * Reading data from the returned object (eg during rendering) will cause the
 * component to subscribe to that data and be rerendered when it changes.
 *
 * @param state the state to observe
 * @returns a reactive object that will cause the component to re-render on
 *  relevant changes
 * @see reactive
 */
export declare function useState<T extends object>(state: T): T;
declare type LifecycleHook = Function;
export declare class ComponentNode<P extends Props = any, E = any> implements VNode<ComponentNode<P, E>> {
    el?: HTMLElement | Text | undefined;
    app: App;
    fiber: Fiber | null;
    component: Component<P, E>;
    bdom: BDom | null;
    status: STATUS;
    forceNextRender: boolean;
    parentKey: string | null;
    props: P;
    nextProps: P | null;
    renderFn: Function;
    parent: ComponentNode | null;
    childEnv: Env;
    children: {
        [key: string]: ComponentNode;
    };
    refs: any;
    willStart: LifecycleHook[];
    willUpdateProps: LifecycleHook[];
    willUnmount: LifecycleHook[];
    mounted: LifecycleHook[];
    willPatch: LifecycleHook[];
    patched: LifecycleHook[];
    willDestroy: LifecycleHook[];
    constructor(C: ComponentConstructor<P, E>, props: P, app: App, parent: ComponentNode | null, parentKey: string | null);
    mountComponent(target: any, options?: MountOptions): void;
    initiateRender(fiber: Fiber | MountFiber): Promise<void>;
    render(deep: boolean): Promise<void>;
    cancel(): void;
    _cancel(): void;
    destroy(): void;
    _destroy(): void;
    updateAndRender(props: P, parentFiber: Fiber): Promise<void>;
    /**
     * Finds a child that has dom that is not yet updated, and update it. This
     * method is meant to be used only in the context of repatching the dom after
     * a mounted hook failed and was handled.
     */
    updateDom(): void;
    /**
     * Sets a ref to a given HTMLElement.
     *
     * @param name the name of the ref to set
     * @param el the HTMLElement to set the ref to. The ref is not set if the el
     *  is null, but useRef will not return elements that are not in the DOM
     */
    setRef(name: string, el: HTMLElement | null): void;
    firstNode(): Node | undefined;
    mount(parent: HTMLElement, anchor: ChildNode): void;
    moveBeforeDOMNode(node: Node | null, parent?: HTMLElement): void;
    moveBeforeVNode(other: ComponentNode<P, E> | null, afterNode: Node | null): void;
    patch(): void;
    _patch(): void;
    beforeRemove(): void;
    remove(): void;
    get name(): string;
    get subscriptions(): ReturnType<typeof getSubscriptions>;
}
export {};
